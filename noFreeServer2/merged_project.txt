// File: cmd/api/main.go
package main

import (
	"mihu007/config"
	"mihu007/internal/handler"
	"mihu007/internal/middleware"
	"mihu007/internal/repository"
	"mihu007/internal/service"
	"mihu007/pkg/database"
	"mihu007/pkg/utils"

	"github.com/gin-gonic/gin"
)

func main() {
	// 加载配置
	cfg := config.Load()

	// 初始化数据库
	db := database.InitMySQL(cfg.Database)

	// 初始化存储层
	userRepo := repository.NewUserRepository(db)
	deviceRepo := repository.NewDeviceRepository(db)
	membershipRepo := repository.NewMembershipRepository(db)

	// 初始化服务层
	jwtUtil := utils.NewJWTUtil(cfg.JWT)
	userService := service.NewUserService(userRepo, jwtUtil)
	deviceService := service.NewDeviceService(deviceRepo)
	membershipService := service.NewMembershipService(membershipRepo)

	// 初始化处理器
	userHandler := handler.NewUserHandler(userService)
	deviceHandler := handler.NewDeviceHandler(deviceService)
	membershipHandler := handler.NewMembershipHandler(membershipService)

	// 设置路由
	r := gin.Default()

	// 公开路由
	public := r.Group("/api/v1")
	{
		public.POST("/user/register", userHandler.Register)
		public.POST("/user/login", userHandler.Login)
		public.POST("/user/password-reset-code", userHandler.SendPasswordResetVerifyCode)
		public.POST("/user/reset-password", userHandler.ResetPassword)
	}

	// 需要认证的路由
	authorized := r.Group("/api/v1")
	authorized.Use(middleware.AuthMiddleware(jwtUtil))
	{
		authorized.GET("/user/info", userHandler.GetInfo)
		authorized.POST("/device/register", deviceHandler.Register)
		authorized.GET("/membership/info", membershipHandler.GetInfo)
		authorized.GET("/membership/info", membershipHandler.GetMembershipInfo)
		authorized.GET("/membership/plans", membershipHandler.GetMembershipPlans)
		authorized.POST("/membership/purchase", membershipHandler.PurchaseMembership)
	}

	// 启动服务器
	r.Run(cfg.Server.Port)
}

###文件分割###

// File: internal/handler/membership.go
package handler

import (
	"mihu007/internal/model"
	"mihu007/internal/service"

	"github.com/gin-gonic/gin"
)

type MembershipHandler struct {
	membershipService service.MembershipService
}

func NewMembershipHandler(membershipService service.MembershipService) *MembershipHandler {
	return &MembershipHandler{
		membershipService: membershipService,
	}
}

func (h *MembershipHandler) GetMembershipInfo(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(401, gin.H{"error": "user not authenticated"})
		return
	}

	info, err := h.membershipService.GetMembershipInfo(c, userID.(uint))
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, info)
}

func (h *MembershipHandler) PurchaseMembership(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(401, gin.H{"error": "user not authenticated"})
		return
	}

	var req model.MembershipPlanRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	order, err := h.membershipService.PurchaseMembership(c, userID.(uint), req.PlanID)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, order)
}

func (h *MembershipHandler) GetMembershipPlans(c *gin.Context) {
	plans, err := h.membershipService.GetMembershipPlans(c)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, plans)
}

###文件分割###

// File: internal/handler/user.go
package handler

import (
	"mihu007/internal/model"
	"mihu007/internal/service"

	"github.com/gin-gonic/gin"
)

type UserHandler struct {
	userService service.UserService
}

func NewUserHandler(userService service.UserService) *UserHandler {
	return &UserHandler{
		userService: userService,
	}
}

func (h *UserHandler) Register(c *gin.Context) {
	var req model.RegisterRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	user, err := h.userService.Register(c, req)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, user)
}

func (h *UserHandler) Login(c *gin.Context) {
	var req model.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	user, token, err := h.userService.Login(c, req)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{
		"user":  user,
		"token": token,
	})
}

func (h *UserHandler) SendPasswordResetVerifyCode(c *gin.Context) {
	var req model.PasswordResetVerifyRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	err := h.userService.SendPasswordResetVerifyCode(c, req)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"message": "verify code sent"})
}

func (h *UserHandler) ResetPassword(c *gin.Context) {
	var req model.PasswordResetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	err := h.userService.ResetPassword(c, req)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"message": "password reset successfully"})
}

###文件分割###

// File: internal/middleware/auth.go
package middleware

import (
	"mihu007/pkg/utils"

	"github.com/gin-gonic/gin"
)

func AuthMiddleware(jwtUtil utils.JWTUtil) gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.GetHeader("Authorization")
		if token == "" {
			c.JSON(401, gin.H{"error": "Authorization header is required"})
			c.Abort()
			return
		}

		claims, err := jwtUtil.ValidateToken(token)
		if err != nil {
			c.JSON(401, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		c.Set("userID", claims.UserID)
		c.Next()
	}
}

###文件分割###

// File: internal/model/device.go
package model

import (
	"time"

	"gorm.io/gorm"
)

type Device struct {
	gorm.Model
	UserID       uint      `gorm:"not null"`
	Fingerprint  string    `gorm:"unique;not null"`
	LastActiveAt time.Time `gorm:"not null"`
	UserAgent    string
	IPAddress    string
	Status       int `gorm:"default:1"` // 0: disabled, 1: active
}

type DeviceRegisterRequest struct {
	Fingerprint string `json:"fingerprint" binding:"required"`
}

###文件分割###

// File: internal/model/membership.go
package model

import (
	"time"

	"gorm.io/gorm"
)

// 会员等级常量
const (
	MemberLevelFree      = 0
	MemberLevelNormal    = 1
	MemberLevelPremium   = 2
	MemberLevelUnlimited = 3
)

type Membership struct {
	gorm.Model
	UserID      uint      `gorm:"not null"`
	Level       int       `gorm:"not null"` // 0: free, 1: normal, 2: premium, 3: unlimited
	ExpireAt    time.Time `gorm:"not null"`
	DeviceLimit int       `gorm:"not null"`
}

type MembershipPlan struct {
	gorm.Model
	Name        string  `gorm:"not null"`
	Level       int     `gorm:"not null"`
	Price       float64 `gorm:"not null"`
	Duration    int     `gorm:"not null"` // 有效期（天）
	DeviceLimit int     `gorm:"not null"`
	Status      int     `gorm:"default:1"` // 0: disabled, 1: active
}

// MembershipPlanRequest 购买会员请求
type MembershipPlanRequest struct {
	PlanID uint `json:"plan_id" binding:"required"`
}

// MembershipInfo 会员信息响应
type MembershipInfo struct {
	Level       int       `json:"level"`
	LevelName   string    `json:"level_name"`
	ExpireAt    time.Time `json:"expire_at"`
	DeviceLimit int       `json:"device_limit"`
	DeviceCount int       `json:"device_count"`
}

###文件分割###

// File: internal/model/user.go
package model

import (
	"gorm.io/gorm"
)

type User struct {
	gorm.Model
	Username     string `gorm:"unique;not null"`
	Email        string `gorm:"unique"`
	Phone        string `gorm:"unique"`
	WechatID     string `gorm:"unique"`
	Password     string `gorm:"not null"`
	RegisterType string `gorm:"not null"`  // phone, email, wechat
	Status       int    `gorm:"default:1"` // 0: disabled, 1: active
}

type LoginRequest struct {
	Username string `json:"username" binding:"required"` // 可以是用户名、邮箱或手机号
	Password string `json:"password" binding:"required"`
}

type RegisterRequest struct {
	Username   string `json:"username" binding:"required"`
	Password   string `json:"password" binding:"required"`
	Email      string `json:"email"`
	Phone      string `json:"phone"`
	VerifyCode string `json:"verify_code" binding:"required"`
}

// PasswordResetRequest 密码重置请求
type PasswordResetRequest struct {
	Email       string `json:"email,omitempty"`
	Phone       string `json:"phone,omitempty"`
	VerifyCode  string `json:"verify_code" binding:"required"`
	NewPassword string `json:"new_password" binding:"required,min=8"`
}

// PasswordResetVerifyRequest 获取密码重置验证码请求
type PasswordResetVerifyRequest struct {
	Email string `json:"email,omitempty"`
	Phone string `json:"phone,omitempty"`
}

###文件分割###

// File: internal/repository/user.go
package repository

import (
	"context"
	"mihu007/internal/model"
	"time"
)

type UserRepository interface {
	Create(ctx context.Context, user *model.User) error
	GetByID(ctx context.Context, id uint) (*model.User, error)
	GetByUsername(ctx context.Context, username string) (*model.User, error)
	GetByEmail(ctx context.Context, email string) (*model.User, error)
	GetByPhone(ctx context.Context, phone string) (*model.User, error)
	UpdatePassword(ctx context.Context, userID uint, newPassword string) error
	Delete(ctx context.Context, id uint) error
}

type VerifyCodeRepository interface {
	Save(ctx context.Context, key string, code string, expireAt time.Time) error
	Verify(ctx context.Context, key string, code string) (bool, error)
}

###文件分割###

// File: internal/service/membership.go
package service

import (
	"context"
	"time"

	"mihu007/internal/model"
	"mihu007/internal/repository"
)

type MembershipService interface {
	GetMembershipInfo(ctx context.Context, userID uint) (*model.MembershipInfo, error)
	PurchaseMembership(ctx context.Context, userID uint, planID uint) (*model.Order, error)
	GetMembershipPlans(ctx context.Context) ([]model.MembershipPlan, error)
}

type membershipService struct {
	membershipRepo repository.MembershipRepository
	deviceRepo     repository.DeviceRepository
	orderRepo      repository.OrderRepository
	planRepo       repository.MembershipPlanRepository
}

func NewMembershipService(
	membershipRepo repository.MembershipRepository,
	deviceRepo repository.DeviceRepository,
	orderRepo repository.OrderRepository,
	planRepo repository.MembershipPlanRepository,
) MembershipService {
	return &membershipService{
		membershipRepo: membershipRepo,
		deviceRepo:     deviceRepo,
		orderRepo:      orderRepo,
		planRepo:       planRepo,
	}
}

func (s *membershipService) GetMembershipInfo(ctx context.Context, userID uint) (*model.MembershipInfo, error) {
	membership, err := s.membershipRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	deviceCount, err := s.deviceRepo.CountByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	levelName := getLevelName(membership.Level)

	return &model.MembershipInfo{
		Level:       membership.Level,
		LevelName:   levelName,
		ExpireAt:    membership.ExpireAt,
		DeviceLimit: membership.DeviceLimit,
		DeviceCount: deviceCount,
	}, nil
}

func (s *membershipService) PurchaseMembership(ctx context.Context, userID uint, planID uint) (*model.Order, error) {
	plan, err := s.planRepo.GetByID(ctx, planID)
	if err != nil {
		return nil, err
	}

	// 创建订单
	order := &model.Order{
		UserID:   userID,
		PlanID:   planID,
		Amount:   plan.Price,
		Status:   "pending",
		ExpireAt: time.Now().Add(5 * time.Minute), // 5分钟后过期
	}

	err = s.orderRepo.Create(ctx, order)
	if err != nil {
		return nil, err
	}

	return order, nil
}

func (s *membershipService) GetMembershipPlans(ctx context.Context) ([]model.MembershipPlan, error) {
	return s.planRepo.GetActivePlans(ctx)
}

func getLevelName(level int) string {
	switch level {
	case model.MemberLevelFree:
		return "免费会员"
	case model.MemberLevelNormal:
		return "普通会员"
	case model.MemberLevelPremium:
		return "高级会员"
	case model.MemberLevelUnlimited:
		return "永久会员"
	default:
		return "未知等级"
	}
}

###文件分割###

// File: internal/service/user.go
package service

import (
	"context"
	"errors"
	"time"

	"mihu007/internal/model"
	"mihu007/internal/repository"
	"mihu007/pkg/utils"
)

type UserService interface {
	Register(ctx context.Context, req model.RegisterRequest) (*model.User, error)
	Login(ctx context.Context, req model.LoginRequest) (*model.User, string, error)
	ResetPassword(ctx context.Context, userID uint, newPassword string) error
	SendPasswordResetVerifyCode(ctx context.Context, req model.PasswordResetVerifyRequest) error
}

type userService struct {
	userRepo       repository.UserRepository
	membershipRepo repository.MembershipRepository
	verifyCodeRepo repository.VerifyCodeRepository
	jwtUtil        utils.JWTUtil
}

func NewUserService(
	userRepo repository.UserRepository,
	membershipRepo repository.MembershipRepository,
	verifyCodeRepo repository.VerifyCodeRepository,
	jwtUtil utils.JWTUtil,
) UserService {
	return &userService{
		userRepo:       userRepo,
		membershipRepo: membershipRepo,
		verifyCodeRepo: verifyCodeRepo,
		jwtUtil:        jwtUtil,
	}
}

func (s *userService) Register(ctx context.Context, req model.RegisterRequest) (*model.User, error) {
	// 1. 验证用户名是否已存在
	existingUser, _ := s.userRepo.GetByUsername(ctx, req.Username)
	if existingUser != nil {
		return nil, errors.New("username already exists")
	}

	// 2. 验证邮箱或手机号是否已存在
	if req.Email != "" {
		if existingUser, _ := s.userRepo.GetByEmail(ctx, req.Email); existingUser != nil {
			return nil, errors.New("email already registered")
		}
	}
	if req.Phone != "" {
		if existingUser, _ := s.userRepo.GetByPhone(ctx, req.Phone); existingUser != nil {
			return nil, errors.New("phone already registered")
		}
	}

	// 3. 验证验证码
	var verifyID string
	if req.Email != "" {
		verifyID = req.Email
	} else if req.Phone != "" {
		verifyID = req.Phone
	} else {
		return nil, errors.New("email or phone is required")
	}

	isValid, err := s.verifyCodeRepo.Verify(ctx, verifyID, req.VerifyCode)
	if err != nil || !isValid {
		return nil, errors.New("invalid verification code")
	}

	// 4. 密码加密
	hashedPassword, err := utils.HashPassword(req.Password)
	if err != nil {
		return nil, err
	}

	// 5. 创建用户
	user := &model.User{
		Username:     req.Username,
		Email:        req.Email,
		Phone:        req.Phone,
		Password:     hashedPassword,
		RegisterType: getRegisterType(req),
	}

	err = s.userRepo.Create(ctx, user)
	if err != nil {
		return nil, err
	}

	// 6. 创建免费会员资格
	membership := &model.Membership{
		UserID:      user.ID,
		Level:       model.MemberLevelFree,
		ExpireAt:    time.Now().AddDate(0, 1, 0), // 一个月有效期
		DeviceLimit: 1,                           // 免费会员只能使用1个设备
	}
	err = s.membershipRepo.Create(ctx, membership)
	if err != nil {
		// 如果创建会员资格失败，需要回滚用户创建
		s.userRepo.Delete(ctx, user.ID)
		return nil, err
	}

	return user, nil
}

func (s *userService) Login(ctx context.Context, req model.LoginRequest) (*model.User, string, error) {
	// 1. 查找用户
	var user *model.User
	var err error

	// 支持使用用户名、邮箱或手机号登录
	if utils.IsEmail(req.Username) {
		user, err = s.userRepo.GetByEmail(ctx, req.Username)
	} else if utils.IsPhone(req.Username) {
		user, err = s.userRepo.GetByPhone(ctx, req.Username)
	} else {
		user, err = s.userRepo.GetByUsername(ctx, req.Username)
	}

	if err != nil {
		return nil, "", errors.New("user not found")
	}

	// 2. 验证密码
	if !utils.CheckPassword(req.Password, user.Password) {
		return nil, "", errors.New("invalid password")
	}

	// 3. 生成 JWT token
	token, err := s.jwtUtil.GenerateToken(user.ID)
	if err != nil {
		return nil, "", err
	}

	return user, token, nil
}

// 辅助函数
func getRegisterType(req model.RegisterRequest) string {
	if req.Email != "" {
		return "email"
	}
	if req.Phone != "" {
		return "phone"
	}
	return "username"
}

func (s *userService) ResetPassword(ctx context.Context, req model.PasswordResetRequest) error {
	var user *model.User
	var err error

	if req.Email != "" {
		user, err = s.userRepo.GetByEmail(ctx, req.Email)
	} else if req.Phone != "" {
		user, err = s.userRepo.GetByPhone(ctx, req.Phone)
	} else {
		return errors.New("email or phone is required")
	}

	if err != nil {
		return err
	}

	// 验证验证码
	valid, err := s.verifyCodeRepo.Verify(ctx, user.ID, req.VerifyCode)
	if err != nil || !valid {
		return errors.New("invalid verify code")
	}

	// 更新密码
	hashedPassword, err := utils.HashPassword(req.NewPassword)
	if err != nil {
		return err
	}

	return s.userRepo.UpdatePassword(ctx, user.ID, hashedPassword)
}
func (s *userService) SendPasswordResetVerifyCode(ctx context.Context, req model.PasswordResetVerifyRequest) error {
	var user *model.User
	var err error

	if req.Email != "" {
		user, err = s.userRepo.GetByEmail(ctx, req.Email)
	} else if req.Phone != "" {
		user, err = s.userRepo.GetByPhone(ctx, req.Phone)
	} else {
		return errors.New("email or phone is required")
	}

	if err != nil {
		return err
	}

	// 生成验证码
	code := utils.GenerateVerifyCode(6)

	// 存储验证码
	err = s.verifyCodeRepo.Save(ctx, user.ID, code, time.Now().Add(15*time.Minute))
	if err != nil {
		return err
	}

	// 发送验证码
	if req.Email != "" {
		return s.emailSender.SendPasswordResetCode(req.Email, code)
	} else {
		return s.smsSender.SendPasswordResetCode(req.Phone, code)
	}
}

###文件分割###

// File: merge_test.go
package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestMerge(t *testing.T) {
	// 指定项目根目录
	root := "."
	// 指定输出文件
	outputFile := "merged_project.txt"

	// 打开输出文件
	out, err := os.Create(outputFile)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		return
	} else {
		fmt.Printf("Created output file: %s\n", outputFile)
	}
	defer out.Close()

	// 遍历目录
	err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// 只处理 .go 文件
		if !info.IsDir() && strings.HasSuffix(path, ".go") && path != "merge.go" && path != outputFile {
			// 写入文件路径作为注释
			fmt.Fprintf(out, "// File: %s\n", path)

			// 读取文件内容
			f, err := os.Open(path)
			if err != nil {
				return err
			}
			defer f.Close()

			_, err = io.Copy(out, f)
			if err != nil {
				return err
			}

			fmt.Fprintln(out)
			// 添加两行######作为分隔
			fmt.Fprintln(out, "###文件分割###")
			fmt.Fprintln(out)
		}
		return nil
	})

	if err != nil {
		fmt.Printf("Error walking the path %v: %v\n", root, err)
		return
	}

	fmt.Printf("All .go files have been merged into %s\n", outputFile)
}

###文件分割###

// File: pkg/utils/jwt.go
package utils

import (
	"time"

	"github.com/golang-jwt/jwt"
)

type JWTUtil interface {
	GenerateToken(userID uint) (string, error)
	ValidateToken(tokenString string) (*JWTClaims, error)
}

type JWTClaims struct {
	UserID uint `json:"user_id"`
	jwt.StandardClaims
}

type jwtUtil struct {
	secretKey     string
	tokenDuration time.Duration
}

func NewJWTUtil(secretKey string, tokenDuration time.Duration) JWTUtil {
	return &jwtUtil{
		secretKey:     secretKey,
		tokenDuration: tokenDuration,
	}
}

func (j *jwtUtil) GenerateToken(userID uint) (string, error) {
	claims := JWTClaims{
		UserID: userID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: time.Now().Add(j.tokenDuration).Unix(),
			IssuedAt:  time.Now().Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(j.secretKey))
}

func (j *jwtUtil) ValidateToken(tokenString string) (*JWTClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(j.secretKey), nil
	})

	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(*JWTClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, jwt.ErrInvalidKey
}

###文件分割###

// File: pkg/utils/password.go
package utils

import (
	"regexp"

	"golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}

func CheckPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func IsEmail(s string) bool {
	re := regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)
	return re.MatchString(s)
}

func IsPhone(s string) bool {
	re := regexp.MustCompile(`^1[3456789]\d{9}$`)
	return re.MatchString(s)
}

###文件分割###

